{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment libdsx  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0.0.1 \par
}}libdsx}
{\comment Generated by doxygen 1.9.6.}
{\creatim \yr2023\mo7\dy29\hr13\min8\sec38}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt libdsx}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 0.0.1\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sat Jul 29 2023 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
dsx::vector | Features{\tc \v dsx::vector | Features}\par \pard\plain 
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor(s): A constructor is used to initialize the vector object. It may have various forms, such as a default constructor, a constructor with initial size, or a constructor that initializes the vector with given values
\par}
{\tc\tcl3 \v Constructor(s): A constructor is used to initialize the vector object. It may have various forms, such as a default constructor, a constructor with initial size, or a constructor that initializes the vector with given values}
\par}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Destructor: A destructor is responsible for releasing any allocated memory and cleaning up resources when the vector object goes out of scope
\par}
{\tc\tcl3 \v Destructor: A destructor is responsible for releasing any allocated memory and cleaning up resources when the vector object goes out of scope}
\par}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Capacity Methods
\par}
{\tc\tcl3 \v Capacity Methods}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>size()</tt>: Returns the current number of elements in the vector
\par}
{\tc\tcl4 \v <tt>size()</tt>: Returns the current number of elements in the vector}
\par}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>capacity()</tt>: Returns the current size of the allocated storage (how many elements the vector can hold without reallocating)
\par}
{\tc\tcl4 \v <tt>capacity()</tt>: Returns the current size of the allocated storage (how many elements the vector can hold without reallocating)}
\par}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>empty()</tt>: Checks whether the vector is empty or not
\par}
{\tc\tcl4 \v <tt>empty()</tt>: Checks whether the vector is empty or not}
\par}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>reserve()</tt>: Requests a change in capacity without changing the vector's size
\par}
{\tc\tcl4 \v <tt>reserve()</tt>: Requests a change in capacity without changing the vector's size}
\par}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>shrink_to_fit()</tt>: Requests the container to reduce its capacity to fit its size
\par}
{\tc\tcl4 \v <tt>shrink_to_fit()</tt>: Requests the container to reduce its capacity to fit its size}
\par}
\par}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Element Access Methods
\par}
{\tc\tcl3 \v Element Access Methods}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>operator[]</tt>: Accesses elements in the vector using the subscript operator
\par}
{\tc\tcl4 \v <tt>operator[]</tt>: Accesses elements in the vector using the subscript operator}
\par}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>at()</tt>: Accesses elements in the vector with bounds checking, throwing an exception if the index is out of range
\par}
{\tc\tcl4 \v <tt>at()</tt>: Accesses elements in the vector with bounds checking, throwing an exception if the index is out of range}
\par}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>front()</tt>: Returns a reference to the first element in the vector
\par}
{\tc\tcl4 \v <tt>front()</tt>: Returns a reference to the first element in the vector}
\par}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>back()</tt>: Returns a reference to the last element in the vector
\par}
{\tc\tcl4 \v <tt>back()</tt>: Returns a reference to the last element in the vector}
\par}
\par}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Modifiers
\par}
{\tc\tcl3 \v Modifiers}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>push_back()</tt>: Adds an element to the end of the vector
\par}
{\tc\tcl4 \v <tt>push_back()</tt>: Adds an element to the end of the vector}
\par}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>pop_back()</tt>: Removes the last element from the vector
\par}
{\tc\tcl4 \v <tt>pop_back()</tt>: Removes the last element from the vector}
\par}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>insert()</tt>: Inserts elements at a specific position
\par}
{\tc\tcl4 \v <tt>insert()</tt>: Inserts elements at a specific position}
\par}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>erase()</tt>: Removes elements at a specific posaition or within a range
\par}
{\tc\tcl4 \v <tt>erase()</tt>: Removes elements at a specific posaition or within a range}
\par}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>clear()</tt>: Removes all elements from the vector
\par}
{\tc\tcl4 \v <tt>clear()</tt>: Removes all elements from the vector}
\par}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>resize()</tt>: Changes the size of the vector
\par}
{\tc\tcl4 \v <tt>resize()</tt>: Changes the size of the vector}
\par}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>swap()</tt>: Swaps the contents of two vectors
\par}
{\tc\tcl4 \v <tt>swap()</tt>: Swaps the contents of two vectors}
\par}
\par}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Other Useful Methods
\par}
{\tc\tcl3 \v Other Useful Methods}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>begin(), end()</tt>: Return iterators to the beginning and end of the vector
\par}
{\tc\tcl4 \v <tt>begin(), end()</tt>: Return iterators to the beginning and end of the vector}
\par}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>rbegin(), rend()</tt>: Return reverse iterators to the beginning and end of the vector
\par}
{\tc\tcl4 \v <tt>rbegin(), rend()</tt>: Return reverse iterators to the beginning and end of the vector}
\par}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>emplace()</tt>: Constructs an element in-place at the given position
\par}
{\tc\tcl4 \v <tt>emplace()</tt>: Constructs an element in-place at the given position}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
These are some common methods you would typically find in a basic vector implementation. More complex vector implementations might include additional methods and features for specialized use cases
\par}
{\tc\tcl4 \v These are some common methods you would typically find in a basic vector implementation. More complex vector implementations might include additional methods and features for specialized use cases}
\par}
\par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
LIBDSX: another guy reinventing the wheel, but it's for learning :D{\tc \v LIBDSX: another guy reinventing the wheel, but it's for learning :D}\par \pard\plain 
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#WARNING : not a lib atm, still gotta figure my head around CMake etc... Just execute build and execute! \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Benchmarking push_back():{\tc \v Benchmarking push_back():}\par \pard\plain 
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterations: 1 Custom vector (int) time: 0.000704 ms Std vector (int) time: 0.000508 ms Winner: Std Vector \par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 0.000196 ms
\par}
{\tc\tcl2 \v Faster by: 0.000196 ms}
Iterations: 10 Custom vector (int) time: 0.025341 ms Std vector (int) time: 0.001104 ms Winner: Std Vector \par}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 0.024237 ms
\par}
{\tc\tcl2 \v Faster by: 0.024237 ms}
Iterations: 100 Custom vector (int) time: 0.020761 ms Std vector (int) time: 0.006023 ms Winner: Std Vector \par}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 0.014738 ms
\par}
{\tc\tcl2 \v Faster by: 0.014738 ms}
Iterations: 1000 Custom vector (int) time: 0.01849 ms Std vector (int) time: 0.052759 ms Winner: Custom Vector \par}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 0.034269 ms
\par}
{\tc\tcl2 \v Faster by: 0.034269 ms}
Iterations: 10000 Custom vector (int) time: 0.14508 ms Std vector (int) time: 0.543974 ms Winner: Custom Vector \par}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 0.398894 ms
\par}
{\tc\tcl2 \v Faster by: 0.398894 ms}
Iterations: 100000 Custom vector (int) time: 1.32824 ms Std vector (int) time: 6.43748 ms Winner: Custom Vector \par}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 5.10923 ms
\par}
{\tc\tcl2 \v Faster by: 5.10923 ms}
Iterations: 1000000 Custom vector (int) time: 20.2598 ms Std vector (int) time: 66.627 ms Winner: Custom Vector \par}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 46.3671 ms
\par}
{\tc\tcl2 \v Faster by: 46.3671 ms}
Iterations: 10000000 Custom vector (int) time: 147.64 ms Std vector (int) time: 485.544 ms Winner: Custom Vector \par}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Faster by: 337.904 ms
\par}
{\tc\tcl2 \v Faster by: 337.904 ms}
Iterations: 100000000 Custom vector (int) time: 1419.08 ms Std vector (int) time: 4013.42 ms Winner: Custom Vector Faster by: 2594.34 ms \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
dsx::vector | Features{\tc \v dsx::vector | Features}\par \pard\plain 
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor(s): A constructor is used to initialize the vector object. It may have various forms, such as a default constructor, a constructor with initial size, or a constructor that initializes the vector with given values
\par}
{\tc\tcl3 \v Constructor(s): A constructor is used to initialize the vector object. It may have various forms, such as a default constructor, a constructor with initial size, or a constructor that initializes the vector with given values}
\par}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Destructor: A destructor is responsible for releasing any allocated memory and cleaning up resources when the vector object goes out of scope
\par}
{\tc\tcl3 \v Destructor: A destructor is responsible for releasing any allocated memory and cleaning up resources when the vector object goes out of scope}
\par}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Capacity Methods
\par}
{\tc\tcl3 \v Capacity Methods}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>size()</tt>: Returns the current number of elements in the vector
\par}
{\tc\tcl4 \v <tt>size()</tt>: Returns the current number of elements in the vector}
\par}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>capacity()</tt>: Returns the current size of the allocated storage (how many elements the vector can hold without reallocating)
\par}
{\tc\tcl4 \v <tt>capacity()</tt>: Returns the current size of the allocated storage (how many elements the vector can hold without reallocating)}
\par}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>empty()</tt>: Checks whether the vector is empty or not
\par}
{\tc\tcl4 \v <tt>empty()</tt>: Checks whether the vector is empty or not}
\par}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>reserve()</tt>: Requests a change in capacity without changing the vector's size
\par}
{\tc\tcl4 \v <tt>reserve()</tt>: Requests a change in capacity without changing the vector's size}
\par}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>shrink_to_fit()</tt>: Requests the container to reduce its capacity to fit its size
\par}
{\tc\tcl4 \v <tt>shrink_to_fit()</tt>: Requests the container to reduce its capacity to fit its size}
\par}
\par}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Element Access Methods
\par}
{\tc\tcl3 \v Element Access Methods}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>operator[]</tt>: Accesses elements in the vector using the subscript operator
\par}
{\tc\tcl4 \v <tt>operator[]</tt>: Accesses elements in the vector using the subscript operator}
\par}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>at()</tt>: Accesses elements in the vector with bounds checking, throwing an exception if the index is out of range
\par}
{\tc\tcl4 \v <tt>at()</tt>: Accesses elements in the vector with bounds checking, throwing an exception if the index is out of range}
\par}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>front()</tt>: Returns a reference to the first element in the vector
\par}
{\tc\tcl4 \v <tt>front()</tt>: Returns a reference to the first element in the vector}
\par}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>back()</tt>: Returns a reference to the last element in the vector
\par}
{\tc\tcl4 \v <tt>back()</tt>: Returns a reference to the last element in the vector}
\par}
\par}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Modifiers
\par}
{\tc\tcl3 \v Modifiers}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>push_back()</tt>: Adds an element to the end of the vector
\par}
{\tc\tcl4 \v <tt>push_back()</tt>: Adds an element to the end of the vector}
\par}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>pop_back()</tt>: Removes the last element from the vector
\par}
{\tc\tcl4 \v <tt>pop_back()</tt>: Removes the last element from the vector}
\par}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>insert()</tt>: Inserts elements at a specific position
\par}
{\tc\tcl4 \v <tt>insert()</tt>: Inserts elements at a specific position}
\par}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>erase()</tt>: Removes elements at a specific posaition or within a range
\par}
{\tc\tcl4 \v <tt>erase()</tt>: Removes elements at a specific posaition or within a range}
\par}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>clear()</tt>: Removes all elements from the vector
\par}
{\tc\tcl4 \v <tt>clear()</tt>: Removes all elements from the vector}
\par}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>resize()</tt>: Changes the size of the vector
\par}
{\tc\tcl4 \v <tt>resize()</tt>: Changes the size of the vector}
\par}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>swap()</tt>: Swaps the contents of two vectors
\par}
{\tc\tcl4 \v <tt>swap()</tt>: Swaps the contents of two vectors}
\par}
\par}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Other Useful Methods
\par}
{\tc\tcl3 \v Other Useful Methods}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>begin(), end()</tt>: Return iterators to the beginning and end of the vector
\par}
{\tc\tcl4 \v <tt>begin(), end()</tt>: Return iterators to the beginning and end of the vector}
\par}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>rbegin(), rend()</tt>: Return reverse iterators to the beginning and end of the vector
\par}
{\tc\tcl4 \v <tt>rbegin(), rend()</tt>: Return reverse iterators to the beginning and end of the vector}
\par}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
<tt>emplace()</tt>: Constructs an element in-place at the given position
\par}
{\tc\tcl4 \v <tt>emplace()</tt>: Constructs an element in-place at the given position}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
These are some common methods you would typically find in a basic vector implementation. More complex vector implementations might include additional methods and features for specialized use cases
\par}
{\tc\tcl4 \v These are some common methods you would typically find in a basic vector implementation. More complex vector implementations might include additional methods and features for specialized use cases}
\par}
\par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
std::exception
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
dsx::structs::exceptions::NegativeIndexExecption\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Node\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
testing::Test
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
VectorTest\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
dsx::structs::vector< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
dsx::structs::vector< int >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b dsx::structs::exceptions::NegativeIndexExecption} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Node} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dsx::structs::vector< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b VectorTest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b src/linked_list/{\b linked_list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/vector/{\b v_exceptions.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/vector/{\b vec_benchmark.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/vector/{\b vec_test.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/vector/{\b vector.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dsx::structs::exceptions::NegativeIndexExecption Class Reference\par \pard\plain 
{\tc\tcl2 \v dsx::structs::exceptions::NegativeIndexExecption}
{\xe \v dsx::structs::exceptions::NegativeIndexExecption}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
Inheritance diagram for dsx::structs::exceptions::NegativeIndexExecption:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1exceptions_1_1_negative_index_execption__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for dsx::structs::exceptions::NegativeIndexExecption:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1exceptions_1_1_negative_index_execption__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

const char * {\b what} () const  throw (){\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/vector/v_exceptions.hpp\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Node Struct Reference\par \pard\plain 
{\tc\tcl2 \v Node}
{\xe \v Node}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Collaboration diagram for Node:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_node__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

int {\b val}{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b Node} * {\b next}{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/linked_list/linked_list.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dsx::structs::vector< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation. }}\par
{
{\f2 #include <vector.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b vector} ()=default\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for the vector class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b vector} (std::initializer_list< T > list)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that initializes the vector with elements from an initializer list. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b vector} (int p_size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that sets the initial size of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~vector} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor for the vector class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b len} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current number of elements in the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b capacity} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current capacity of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_empty} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the vector is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reserve} (int n_size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reserves memory for a given number of elements in the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shrink} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reduces the vector's capacity to fit its size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b at} (int p_idx) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element at the specified index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator[]} (int p_idx) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at the specified index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b front} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the first element in the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b back} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the last element in the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push} (const T &elt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an element to the end of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::optional< T > {\b pop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and returns the last element of the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert_at} (const T &elt, int idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an element at the specified index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::optional< T > {\b erase_at} (int idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and returns the element at the specified index. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all elements from the vector. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} (int n_size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the vector to the specified size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b vector}< T > &o_vec)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swaps the contents of two vectors. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
class dsx::structs::vector< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The vector class provides a dynamic array-based container for holding elements of a specified type. It automatically resizes its underlying array to accommodate the elements as they are added or removed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{The type of elements held in the vector. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cap} \cell }{The initial capacity of the vector. Defaults to 5. \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v vector\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b dsx::structs::vector}< T >::vector (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor for the vector class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor creates an empty vector with the default initial capacity. \par
}}
{\xe \v vector\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b dsx::structs::vector}< T >::vector (std::initializer_list< T >  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that initializes the vector with elements from an initializer list. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor creates a vector with the elements provided in the given initializer list. It sets the length of the vector to the number of elements in the initializer list.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i list} \cell }{An initializer list containing elements to be stored in the vector. \cell }
{\row }
}
}}
{\xe \v vector\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b dsx::structs::vector}< T >::vector (int  {\i p_size}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor that sets the initial size of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor creates a vector with the specified initial size. It allocates memory for the underlying array with the given size and sets the capacity accordingly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p_size} \cell }{The initial size of the vector. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::runtime_error} \cell }{If memory allocation fails. \cell }
{\row }
}
}}
{\xe \v ~vector\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:~vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b dsx::structs::vector}< T >::~{\b vector} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor for the vector class. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This destructor automatically deallocates the memory used by the underlying array when the vector goes out of scope. It ensures that there are no memory leaks and releases the resources held by the vector. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v at\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b dsx::structs::vector}< T >::at (int  {\i p_idx}) const}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the element at the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function provides access to the element at the specified index in the vector. It performs boundary checks to ensure that the index is within the valid range of the vector. If the index is out of range, the function throws an std::out_of_range exception.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p_idx} \cell }{The index of the element to access. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The element at the specified index. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::out_of_range} \cell }{If the index is out of range. \cell }
{\row }
}
}}
{\xe \v back\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T & {\b dsx::structs::vector}< T >::back () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the last element in the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function provides access to the last element in the vector. It is used to retrieve the last element when the vector is not empty. It does not check if the vector is empty; calling this function on an empty vector results in undefined behavior.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A reference to the last element in the vector. \par
}}}}
{\xe \v capacity\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > int {\b dsx::structs::vector}< T >::capacity () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current capacity of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns the current capacity of the vector, which represents the maximum number of elements that can be stored without reallocation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current capacity of the vector. \par
}}}}
{\xe \v clear\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::clear}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all elements from the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes all elements from the vector, leaving it empty. It deallocates the memory used by the underlying array and resets the length and capacity to zero.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::runtime_error} \cell }{If memory reallocation fails while clearing the vector. \cell }
{\row }
}
}}
{\xe \v erase_at\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:erase_at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::optional< T > {\b dsx::structs::vector}< T >::erase_at (int  {\i idx})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and returns the element at the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes the element at the specified index in the vector and returns it as an optional value. If the index is out of range, the function returns an empty optional (std::nullopt).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i idx} \cell }{The index of the element to be removed. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
An optional containing the removed element if the index is valid, or an empty optional if the index is out of range. \par
}}}}
{\xe \v front\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > const T & {\b dsx::structs::vector}< T >::front () const{\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the first element in the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function provides access to the first element in the vector. It is used to retrieve the first element when the vector is not empty. It does not check if the vector is empty; calling this function on an empty vector results in undefined behavior.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A reference to the first element in the vector. \par
}}}}
{\xe \v insert_at\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:insert_at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::insert_at (const T &  {\i elt}, int  {\i idx})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an element at the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function inserts a new element at the specified index in the vector. If the index is greater than or equal to the current length of the vector, the function behaves like {\f2 push}  and adds the element to the end of the vector. If the vector's size is about to exceed its current capacity, the function doubles the capacity and reallocates memory for the underlying array to accommodate the new element efficiently.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i elt} \cell }{The element to be inserted into the vector. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i idx} \cell }{The index at which the element should be inserted. \cell }
{\row }
}
}Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_ae003c0c56d315d6e0446192a5e268183_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_empty\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b dsx::structs::vector}< T >::is_empty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check if the vector is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks whether the vector is empty, i.e., if it contains no elements.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True if the vector is empty, false otherwise. \par
}}}Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_a326cc2694be88ca78dfe7b6fd7e559df_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_a326cc2694be88ca78dfe7b6fd7e559df_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v len\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > int {\b dsx::structs::vector}< T >::len () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current number of elements in the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns the current number of elements present in the vector.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The number of elements in the vector. \par
}}}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_aea26229420a6bbf1cbd2a77a22290753_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T & {\b dsx::structs::vector}< T >::operator[] (int  {\i p_idx}) const}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This operator provides direct access to the element at the specified index in the vector. It performs boundary checks to ensure that the index is within the valid range of the vector. If the index is out of range, the operator throws an std::out_of_range exception.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i idx} \cell }{The index of the element to access. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A reference to the element at the specified index. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::out_of_range} \cell }{If the index is out of range. \cell }
{\row }
}
}}
{\xe \v pop\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:pop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > std::optional< T > {\b dsx::structs::vector}< T >::pop}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes and returns the last element of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function removes the last element of the vector and returns it as an optional value. If the vector is empty, the function returns an empty optional (std::nullopt).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
An optional containing the last element of the vector if the vector is not empty, or an empty optional if the vector is empty. \par
}}}Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_a2a8f7c5710eaac9b06a7366e426bc126_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v push\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:push}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::push (const T &  {\i elt})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an element to the end of the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds a new element to the end of the vector. If the vector's size is about to exceed its current capacity, the function doubles the capacity and reallocates memory for the underlying array to accommodate the new element efficiently.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i elt} \cell }{The element to be added to the end of the vector. \cell }
{\row }
}
}Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_a5e086b46fe16e1d3cddfeb57394a2b4a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_a5e086b46fe16e1d3cddfeb57394a2b4a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reserve\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:reserve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::reserve (int  {\i n_size})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reserves memory for a given number of elements in the vector. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the requested size is less than or equal to the current capacity, the function does nothing. Otherwise, it allocates memory for the specified number of elements and copies the existing elements to the newly allocated memory. The function updates the capacity of the vector accordingly.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n_size} \cell }{The number of elements to reserve memory for. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::runtime_error} \cell }{If memory allocation fails. \cell }
{\row }
}
}Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_a0d6e589875e22d2e17d2ea1deba69abd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resize\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::resize (int  {\i n_size})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resizes the vector to the specified size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function resizes the vector to the specified size. If the new size is smaller than the current length, elements at the end of the vector are removed. If the new size is larger than the current length, the vector's capacity is adjusted to accommodate the new size efficiently.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n_size} \cell }{The new size of the vector. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::runtime_error} \cell }{If memory reallocation fails while resizing the vector. \cell }
{\row }
}
}Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classdsx_1_1structs_1_1vector_ab7612d091ae431bc5e95b707f2db395f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v shrink\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:shrink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::shrink}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reduces the vector's capacity to fit its size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deallocates the unused memory from the underlying array, reducing the vector's capacity to be equal to the number of elements it contains. If the vector is empty, the function does nothing.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::runtime_error} \cell }{If memory reallocation fails while shrinking. \cell }
{\row }
}
}}
{\xe \v swap\:dsx::structs::vector< T >}
{\xe \v dsx::structs::vector< T >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > void {\b dsx::structs::vector}< T >::swap ({\b vector}< T > &  {\i o_vec})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Swaps the contents of two vectors. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function swaps the contents of the current vector with the contents of another vector. It exchanges the lengths, capacities, and underlying arrays of the two vectors.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o_vec} \cell }{The reference to the vector to be swapped with the current vector. \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/vector/{\b vector.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
VectorTest Class Reference\par \pard\plain 
{\tc\tcl2 \v VectorTest}
{\xe \v VectorTest}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
Inheritance diagram for VectorTest:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_vector_test__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for VectorTest:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_vector_test__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b SetUp} () override{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b dsx::structs::vector}< int > {\b emptyVector}{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b dsx::structs::vector}< int > {\b filledVector}{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
main.cxx\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
linked_list.h\par \pard\plain 
{\tc\tcl2 \v src/linked_list/linked_list.h}
{\xe \v src/linked_list/linked_list.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //}\par
2 {\cf20 // Created by Ayman Ougri on 7/22/23.}\par
3 {\cf20 //}\par
4 \par
5 {\cf21 #ifndef LIBDSX_LINKED_LIST_H}\par
6 {\cf21 #define LIBDSX_LINKED_LIST_H}\par
7 \par
8 {\cf17 struct }Node \{\par
9   {\cf18 int} val;\par
10 \par
11   Node *next;\par
12 \};\par
13 \par
14 {\cf21 #endif }{\cf20 // LIBDSX_LI}\par
15        {\cf20 //}\par
16        {\cf20 // NKED_LIST_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
v_exceptions.hpp\par \pard\plain 
{\tc\tcl2 \v src/vector/v_exceptions.hpp}
{\xe \v src/vector/v_exceptions.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
2 {\cf21 #ifndef LIBDSX_VEC_EXCEPTIONS}\par
3 {\cf21 #define LIBDSX_VEC_EXCEPTIONS}\par
4 {\cf21 #include <exception>}\par
5 {\cf21 #include <string>}\par
6 \par
7 {\cf17 namespace }dsx::structs::exceptions \{\par
8 {\cf17 class }NegativeIndexExecption : {\cf17 public} std::exception \{\par
9 {\cf17 public}:\par
10 \par
11   {\cf17 const} {\cf18 char} * what () {\cf17 const} {\cf19 throw} ()\par
12     \{\par
13     {\cf19 return} {\cf22 "NegativeIndexExecption: index became negative"};\par
14     \}\par
15 \};\par
16 \}\par
17 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vec_benchmark.hpp\par \pard\plain 
{\tc\tcl2 \v src/vector/vec_benchmark.hpp}
{\xe \v src/vector/vec_benchmark.hpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #include "vector.hpp"}\par
2 {\cf21 #include <chrono>}\par
3 {\cf21 #include <cmath>}\par
4 {\cf21 #include <iostream>}\par
5 {\cf21 #include <vector>}\par
6 \par
7 {\cf17 template} <{\cf17 typename} T>\par
8 {\cf18 double} benchmarkCustomVectorPushBack({\cf18 long} {\cf18 long} iterations) \{\par
9   dsx::structs::vector<T> custom_vector(iterations);\par
10 \par
11   {\cf17 auto} start = std::chrono::high_resolution_clock::now();\par
12   {\cf19 for} ({\cf18 int} i = 0; i < iterations; ++i) \{\par
13     custom_vector.push(i);\par
14   \}\par
15   {\cf17 auto} end = std::chrono::high_resolution_clock::now();\par
16 \par
17   std::chrono::duration<double> duration = end - start;\par
18   {\cf19 return} duration.count() * 1000.0;\par
19 \}\par
20 \par
21 {\cf17 template} <{\cf17 typename} T> {\cf18 double} benchmarkStdVectorPushBack({\cf18 long} {\cf18 long} iterations) \{\par
22   std::vector<T> std_vector;\par
23   std_vector.reserve(iterations);\par
24   {\cf17 auto} start = std::chrono::high_resolution_clock::now();\par
25   {\cf19 for} ({\cf18 int} i = 0; i < iterations; ++i) \{\par
26     std_vector.push_back(i);\par
27   \}\par
28   {\cf17 auto} end = std::chrono::high_resolution_clock::now();\par
29 \par
30   std::chrono::duration<double> duration = end - start;\par
31   {\cf19 return} duration.count() * 1000.0;\par
32 \}\par
33 \par
34 {\cf17 inline} {\cf18 int} vec_bench() \{\par
35   std::vector<long long> iters;\par
36   {\cf19 for} ({\cf18 int} i = 0; i <= 6; i++) \{\par
37     iters.push_back(pow(10, i));\par
38   \}\par
39 \par
40   std::cout << {\cf22 "Benchmarking push_back():\\n"};\par
41   std::cout << {\cf22 "------------------------\\n"};\par
42 \par
43   {\cf19 for} ({\cf18 long} {\cf18 long} iteration : iters) \{\par
44     std::cout << {\cf22 "Iterations: "} << iteration << std::endl;\par
45 \par
46     {\cf20 // Benchmarking int}\par
47     {\cf18 double} custom_int_time = benchmarkCustomVectorPushBack<int>(iteration);\par
48     {\cf18 double} std_int_time = benchmarkStdVectorPushBack<int>(iteration);\par
49 \par
50     std::cout << {\cf22 "Custom vector (int) time: "} << custom_int_time << {\cf22 " ms\\n"};\par
51     std::cout << {\cf22 "Std vector (int) time: "} << std_int_time << {\cf22 " ms\\n"};\par
52     std::cout << {\cf22 "Winner: "}\par
53               << ((custom_int_time < std_int_time) ? {\cf22 "Custom Vector"}\par
54                                                    : {\cf22 "Std Vector"})\par
55               << {\cf22 "\\n"};\par
56     std::cout << {\cf22 "Faster by: "}\par
57               << ((custom_int_time < std_int_time)\par
58                       ? (std_int_time - custom_int_time)\par
59                       : (custom_int_time - std_int_time))\par
60               << {\cf22 " ms\\n"};\par
61     std::cout << {\cf22 "---------------------------------\\n"};\par
62   \}\par
63 \par
64   {\cf19 return} 0;\par
65 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vec_test.hpp\par \pard\plain 
{\tc\tcl2 \v src/vector/vec_test.hpp}
{\xe \v src/vector/vec_test.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #include "vector.hpp"}\par
2 {\cf21 #include <cassert>}\par
3 {\cf21 #include <iostream>}\par
4 \par
5 {\cf20 // Helper macro for test assertions}\par
6 {\cf21 #define ASSERT(condition)                                                      \\}\par
7 {\cf21   do \{                                                                         \\}\par
8 {\cf21     if (!(condition)) \{                                                        \\}\par
9 {\cf21       std::cerr << "Assertion failed at line "} << __LINE__ << " in function "  \\\par
10                 << __FUNCTION__ << ": " << #condition << std::endl;            \\\par
11       exit(-1);                                                                \\\par
12     \}                                                                          \\\par
13   \} while (0)\par
14 \par
15 {\cf17 inline} {\cf18 int} vec_test() \{\par
16   {\cf20 // Test 1: Default constructor}\par
17   dsx::structs::vector<int> v1;\par
18   ASSERT(v1.len() == 0);\par
19   ASSERT(v1.capacity() == 5);\par
20   std::cout << {\cf22 "Test 1 (Default Constructor) passed!"} << std::endl;\par
21 \par
22   {\cf20 // Test 2: Initializer_list constructor}\par
23   dsx::structs::vector<int> v2 = \{1, 2, 3\};\par
24   ASSERT(v2.len() == 3);\par
25   ASSERT(v2.capacity() == 5);\par
26   ASSERT(v2[0] == 1);\par
27   ASSERT(v2[1] == 2);\par
28   ASSERT(v2[2] == 3);\par
29   std::cout << {\cf22 "Test 2 (Initializer_list Constructor) passed!"} << std::endl;\par
30 \par
31   {\cf20 // Test 3: Size constructor}\par
32   dsx::structs::vector<int> v3(4);\par
33   ASSERT(v3.len() == 0);\par
34   ASSERT(v3.capacity() == 4);\par
35   std::cout << {\cf22 "Test 3 (Size Constructor) passed!"} << std::endl;\par
36 \par
37   {\cf20 // Test 4: Push and Pop}\par
38   v1.push(10);\par
39   v1.push(20);\par
40   v1.push(30);\par
41   ASSERT(v1.len() == 3);\par
42   ASSERT(v1[0] == 10);\par
43   ASSERT(v1[1] == 20);\par
44   ASSERT(v1[2] == 30);\par
45   {\cf17 auto} popped = v1.pop();\par
46   ASSERT(popped.has_value());\par
47   ASSERT(popped.value() == 30);\par
48   ASSERT(v1.len() == 2);\par
49   std::cout << {\cf22 "Test 4 (Push and Pop) passed!"} << std::endl;\par
50 \par
51   {\cf20 // Test 5: Insert_at}\par
52   dsx::structs::vector<int> v4 = \{1, 2, 3\};\par
53   v4.insert_at(0, 0);\par
54   v4.insert_at(4, 4);\par
55   ASSERT(v4.len() == 5);\par
56   ASSERT(v4[0] == 0);\par
57   ASSERT(v4[1] == 1);\par
58   ASSERT(v4[2] == 2);\par
59   ASSERT(v4[3] == 3);\par
60   ASSERT(v4[4] == 4);\par
61   std::cout << {\cf22 "Test 5 (Insert_at) passed!"} << std::endl;\par
62 \par
63   {\cf20 // Test 6: Erase_at}\par
64   dsx::structs::vector<int> v5 = \{1, 2, 3\};\par
65   {\cf17 auto} erased = v5.erase_at(1);\par
66   ASSERT(erased.has_value() && erased.value() == 2);\par
67   ASSERT(v5.len() == 2);\par
68   ASSERT(v5[0] == 1);\par
69   ASSERT(v5[1] == 3);\par
70   std::cout << {\cf22 "Test 6 (Erase_at) passed!"} << std::endl;\par
71 \par
72   {\cf20 // Test 7: Clear}\par
73   dsx::structs::vector<int> v6 = \{1, 2, 3\};\par
74   v6.clear();\par
75   ASSERT(v6.len() == 0);\par
76   ASSERT(v6.capacity() == 5);\par
77   std::cout << {\cf22 "Test 7 (Clear) passed!"} << std::endl;\par
78 \par
79   {\cf20 // Test 8: Resize}\par
80   dsx::structs::vector<int> v7 = \{1, 2, 3\};\par
81   v7.resize(2);\par
82   ASSERT(v7.len() == 2);\par
83   ASSERT(v7[0] == 1);\par
84   ASSERT(v7[1] == 2);\par
85   std::cout << {\cf22 "Test 8 (Resize) passed!"} << std::endl;\par
86 \par
87   {\cf20 // Test 9: Swap}\par
88   dsx::structs::vector<int> v8 = \{1, 2, 3\};\par
89   dsx::structs::vector<int> v9 = \{4, 5, 6, 3\};\par
90   v8.swap(v9);\par
91   ASSERT(v8.len() == 4 && v8[0] == 4 && v8[1] == 5 && v8[2] == 6);\par
92   ASSERT(v9.len() == 3 && v9[0] == 1 && v9[1] == 2 && v9[2] == 3);\par
93   std::cout << {\cf22 "Test 9 (Swap) passed!"} << std::endl;\par
94 \par
95   std::cout << {\cf22 "All tests passed!"} << std::endl;\par
96 \par
97   {\cf19 return} 0;\par
98 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/vector/vector.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/vector/vector.hpp}
{\xe \v src/vector/vector.hpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "v_exceptions.hpp"}\par
{\f2 #include <algorithm>}\par
{\f2 #include <array>}\par
{\f2 #include <cstddef>}\par
{\f2 #include <initializer_list>}\par
{\f2 #include <iostream>}\par
{\f2 #include <memory>}\par
{\f2 #include <optional>}\par
{\f2 #include <sstream>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <string>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for vector.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vector_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "vector_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b dsx::structs::vector< T >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A dynamic array-based vector container implementation. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vector.hpp\par \pard\plain 
{\tc\tcl2 \v src/vector/vector.hpp}
{\xe \v src/vector/vector.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
6 {\cf21 #pragma once}\par
7 \par
8 {\cf21 #include "v_exceptions.hpp"}\par
9 {\cf21 #include <algorithm>}\par
10 {\cf21 #include <array>}\par
11 {\cf21 #include <cstddef>}\par
12 {\cf21 #include <initializer_list>}\par
13 {\cf21 #include <iostream>}\par
14 {\cf21 #include <memory>}\par
15 {\cf21 #include <optional>}\par
16 {\cf21 #include <sstream>}\par
17 {\cf21 #include <stdexcept>}\par
18 {\cf21 #include <string>}\par
19 \par
20 {\cf17 namespace }dsx::structs \{\par
21 \par
32 {\cf17 template} <{\cf17 typename} T> {\cf17 class }vector \{\par
33 {\cf17 private}:\par
34   {\cf18 int} _cap = 5;\par
35   T *_arr = {\cf17 new} T[_cap];\par
36   {\cf18 int} _len = \{0\};\par
37 \par
38 {\cf17 public}:\par
44   vector() = {\cf19 default};\par
45 \par
57   vector(std::initializer_list<T> list) : _len(list.size()) \{\par
58     _arr = {\cf17 new} T[_cap]; {\cf20 // Allocate memory for the array}\par
59     std::copy(list.begin(), list.end(),\par
60               _arr); {\cf20 // Copy elements from the initializer list to the array}\par
61   \}\par
62 \par
73   {\cf17 explicit} vector({\cf18 int} p_size) \{\par
74     T *n_arr =\par
75         {\cf17 new} T[p_size]; {\cf20 // Allocate memory for the new array with the given size}\par
76 \par
77     {\cf17 delete}[] _arr; {\cf20 // Deallocate memory from the previous array}\par
78 \par
79     _arr = n_arr; {\cf20 // Update the pointer to the newly allocated array}\par
80 \par
81     {\cf19 if} (!_arr) \{\par
82       std::stringstream ss;\par
83       ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
84          << {\cf22 " in function: "} << __FUNCTION__;\par
85       {\cf19 throw} std::runtime_error(\par
86           ss.str()); {\cf20 // Throw an error if memory allocation fails}\par
87     \}\par
88 \par
89     _cap = p_size; {\cf20 // Update the capacity of the vector}\par
90   \}\par
91 \par
99   ~vector() \{ {\cf17 delete}[] _arr; \}\par
100 \par
101 {\cf17 public}:\par
109   [[nodiscard]] {\cf18 int} len(){\cf17  const }\{ {\cf19 return} _len; \}\par
110 \par
119   [[nodiscard]] {\cf18 int} capacity(){\cf17  const }\{ {\cf19 return} _cap; \}\par
120 \par
129   [[nodiscard]] {\cf18 bool} is_empty(){\cf17  const }\{ {\cf19 return} len() == 0; \}\par
130 \par
142   {\cf18 void} reserve({\cf18 int} n_size);\par
143 \par
153   {\cf18 void} shrink();\par
154 \par
167   T at({\cf18 int} p_idx) {\cf17 const};\par
168 \par
181   T &operator[]({\cf18 int} p_idx) {\cf17 const};\par
182 \par
193   {\cf17 const} T &front() const noexcept;\par
194 \par
205   const T &back() const noexcept;\par
206 \par
217   {\cf18 void} push(const T &elt);\par
218 \par
229   std::optional<T> pop();\par
230 \par
244   {\cf18 void} insert_at(const T &elt, {\cf18 int} idx);\par
245 \par
257   std::optional<T> erase_at({\cf18 int} idx);\par
258 \par
269   {\cf18 void} clear();\par
270 \par
283   {\cf18 void} resize({\cf18 int} n_size);\par
284 \par
295   {\cf18 void} swap(vector<T> &o_vec);\par
296 \};\par
297 \par
298 \} {\cf20 // namespace dsx::structs}\par
299 template <typename T>\par
300 {\cf18 void} dsx::structs::vector<T>::reserve({\cf18 int} n_size) noexcept(false) \{\par
301   {\cf19 if} (n_size <= _cap) \{\par
302     {\cf19 return};\par
303   \}\par
304 \par
305   T *new_arr = {\cf17 new} T[n_size];\par
306   {\cf19 if} (!new_arr) \{\par
307     {\cf17 delete}[] new_arr;\par
308     std::stringstream ss;\par
309     ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
310        << {\cf22 " in function: "} << __FUNCTION__;\par
311     {\cf19 throw} std::runtime_error(ss.str());\par
312   \}\par
313 \par
314   std::copy(_arr, _arr + _len, new_arr);\par
315   {\cf17 delete}[] _arr;\par
316   _arr = new_arr;\par
317   _cap = n_size;\par
318 \}\par
319 \par
320 {\cf17 template} <{\cf17 typename} T> {\cf18 void} dsx::structs::vector<T>::shrink() noexcept(false) \{\par
321   {\cf19 if} (_len == 0) \{\par
322     {\cf19 return};\par
323   \}\par
324 \par
325   T *new_arr = {\cf17 new} T[_len];\par
326   {\cf19 if} (!new_arr) \{\par
327     {\cf17 delete}[] new_arr;\par
328     std::stringstream ss;\par
329     ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
330        << {\cf22 " in function: "} << __FUNCTION__;\par
331     {\cf19 throw} std::runtime_error(ss.str());\par
332   \}\par
333   std::copy(_arr, _arr + _len, new_arr);\par
334   {\cf17 delete}[] _arr;\par
335   _arr = new_arr;\par
336   {\cf19 if} (!_arr) \{\par
337     {\cf17 delete}[] new_arr;\par
338     std::stringstream ss;\par
339     ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
340        << {\cf22 " in function: "} << __FUNCTION__;\par
341     {\cf19 throw} std::runtime_error(ss.str());\par
342   \}\par
343   _cap = _len;\par
344 \}\par
345 \par
346 {\cf17 template} <{\cf17 typename} T> {\cf18 void} dsx::structs::vector<T>::push({\cf17 const} T &elt) \{\par
347   {\cf19 if} (_len + 1 >= _cap) \{\par
348     reserve(_cap * 2 * {\cf17 sizeof}(*_arr));\par
349     _cap *= 2;\par
350   \}\par
351 \par
352   _arr[_len] = elt;\par
353   _len++;\par
354 \}\par
355 \par
356 {\cf17 template} <{\cf17 typename} T> std::optional<T> dsx::structs::vector<T>::pop() \{\par
357   {\cf19 if} (is_empty()) \{\par
358     {\cf19 return} std::nullopt;\par
359   \}\par
360 \par
361   {\cf17 auto} popped = _arr[_len - 1];\par
362   _arr[_len - 1] = \{\};\par
363   --_len;\par
364 \par
365   {\cf19 return} popped;\par
366 \}\par
367 \par
368 {\cf17 template} <{\cf17 typename} T>\par
369 {\cf18 void} dsx::structs::vector<T>::insert_at({\cf17 const} T &elt, {\cf18 int} idx) {\cf17 noexcept}({\cf17 false}) \{\par
370   {\cf19 if} (idx >= _len) \{\par
371     push(elt);\par
372   \} {\cf19 else} \{\par
373     {\cf19 if} (_len == _cap) \{\par
374       _cap = (_cap == 0) ? 5 : _cap * 2;\par
375       T *new_arr = {\cf17 new} T[_cap];\par
376 \par
377       std::copy(_arr, _arr + idx, new_arr);\par
378       new_arr[idx] = elt;\par
379       std::copy(_arr + idx, _arr + _len, new_arr + idx + 1);\par
380 \par
381       {\cf17 delete}[] _arr;\par
382       _arr = new_arr;\par
383 \par
384       {\cf19 if} (!_arr) \{\par
385         std::stringstream ss;\par
386         ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
387            << {\cf22 " in function: "} << __FUNCTION__;\par
388         {\cf19 throw} std::runtime_error(ss.str());\par
389       \}\par
390 \par
391       _len++;\par
392     \} {\cf19 else} \{\par
393       {\cf19 for} ({\cf18 int} i = _len; i > idx; --i) \{\par
394         _arr[i] = _arr[i - 1];\par
395       \}\par
396 \par
397       _arr[idx] = elt;\par
398       _len++;\par
399     \}\par
400   \}\par
401 \}\par
402 \par
403 {\cf17 template} <{\cf17 typename} T>\par
404 std::optional<T> dsx::structs::vector<T>::erase_at({\cf18 int} idx) \{\par
405   {\cf19 if} (idx >= _len) \{\par
406     {\cf19 return} std::nullopt;\par
407   \}\par
408 \par
409   T erased_value = _arr[idx];\par
410   std::copy(_arr + idx + 1, _arr + _len, _arr + idx);\par
411   _len--;\par
412 \par
413   {\cf19 return} erased_value;\par
414 \}\par
415 \par
416 {\cf17 template} <{\cf17 typename} T> {\cf18 void} dsx::structs::vector<T>::clear() noexcept(false) \{\par
417   T *n_arr = {\cf17 new} T[_cap];\par
418   {\cf17 delete}[] _arr;\par
419   _arr = n_arr;\par
420 \par
421   {\cf19 if} (!_arr) \{\par
422     std::stringstream ss;\par
423     ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
424        << {\cf22 " in function: "} << __FUNCTION__;\par
425     {\cf19 throw} std::runtime_error(ss.str());\par
426   \}\par
427 \par
428   this->_cap = _cap;\par
429   this->_len = 0;\par
430 \}\par
431 \par
432 {\cf17 template} <{\cf17 typename} T> {\cf18 void} dsx::structs::vector<T>::resize({\cf18 int} n_size) \{\par
433   {\cf19 if} (n_size < _len) \{\par
434     _len = n_size;\par
435   \} {\cf19 else} {\cf19 if} (n_size > _len && n_size > _cap) \{\par
436     reserve(n_size);\par
437   \}\par
438 \par
439   {\cf19 if} (!_arr) \{\par
440     std::stringstream ss;\par
441     ss << {\cf22 "Memory reallocation failed at line: "} << __LINE__\par
442        << {\cf22 " in function: "} << __FUNCTION__;\par
443     {\cf19 throw} std::runtime_error(ss.str());\par
444   \}\par
445 \}\par
446 \par
447 {\cf17 template} <{\cf17 typename} T>\par
448 {\cf18 void} dsx::structs::vector<T>::swap(dsx::structs::vector<T> &o_vec) \{\par
449   std::swap(this->_len, o_vec._len);\par
450   std::swap(this->_arr, o_vec._arr);\par
451   std::swap(this->_cap, o_vec._cap);\par
452 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
